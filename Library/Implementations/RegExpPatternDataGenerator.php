<?php

class RegExpPatternDataGenerator implements IPatternDataGenerator
{
	protected $_pattern;
	
	// maximum length of strings generated by repetation (+, *, {n,n}) operators
	public $maxRepetationCount = 16; 
	
	// meaning of the "." character
	public $whole_set;
		
	protected static $_deliminatorPattern = '';
	
	public function __construct()
	{
		$this->_pattern = '';
		$this->whole_set = join('', array_merge(range('a','z'), range('A','Z'), range('0','9')));
		$this->whole_set .= " \t!\"#\$%&'()*+,-./:;<=>?@\[\]\\^_`{|}~";
		
		if (empty(self::$_deliminatorPattern))
		{
			// Build tokenizer rules
			$deliminators = array();		
			$deliminators[] = '\\\\x[0-9a-fA-F]{1,2}';	// support the \xHH syntax
			$deliminators[] = '\\\\c[A-Z]';	// support the \cX syntax
			$deliminators[] = '\\\\[0-9]{1,2}'; // support back-references (\nn syntax)
			$deliminators[] = '\\\\Q.*?\\\\E|\\\\Q.*?$'; // support escaping as literals (\Q...\E syntax)
			$deliminators[] = '\\\\.'; // support escaping special characters
			$deliminators[] = '\$\{[0-9]{1,2}\}'; // support back-references (${nn} syntax)
			$deliminators[] = '\$[0-9]{1,2}'; // support back-references ($nn syntax)
			$deliminators[] = '\?:'; // support non-capturing subpatterns
			$deliminators[] = '\(((?>[^()]*)|(?R))*\)'; // support subpatterns
			$deliminators[] = '[\w]\-[\w]'; // support alpha-numeric intervals
			$deliminators[] = '\{\d+,?\}|\{\d+,\d+\}'; // support the repetation operators ({n}, {n,}, {n,n})			
			$deliminators[] = '.'; // pass-thru everything else to the phase 2
			
			$deliminators = array_map(create_function('$deliminator', 'return "($deliminator)";'), $deliminators);
			self::$_deliminatorPattern = '/'.join('|', $deliminators).'/sD';
		}
	}
	
	public function SetPattern($Pattern)
	{
		$this->_pattern = $Pattern;
	}
	
	public function GetPattern()
	{
		return $this->_pattern;
	}	
	
	protected function _Prepare($Pattern)
	{
		// protect escaped back-slashes
		$Pattern = str_replace('\\\\', '{\\\\}', $Pattern);
		
		// ignore the beginning/ending of line/data rules
		$Pattern = preg_replace('/^[\^]/', '', $Pattern);
		$Pattern = preg_replace('/([^\\\])\$$/', '$1', $Pattern);
		$Pattern = preg_replace('/^\\\A/', '', $Pattern);
		$Pattern = preg_replace('/\\\Z$/', '', $Pattern);
		
		// Support for PCRE character properties
		$Pattern = str_replace('\S', '[^\s]', $Pattern);
		$Pattern = str_replace('\s', "[ \t\n\r]", $Pattern);
		$Pattern = str_replace('\B', '\w', $Pattern);
		$Pattern = str_replace('\b', '\W', $Pattern);
		$Pattern = str_replace('\W', '[^\w]', $Pattern);
		$Pattern = str_replace('\w', '[a-zA-Z\d_]', $Pattern);
		$Pattern = str_replace('\D', '[^\d]', $Pattern);
		$Pattern = str_replace('\d', '[0-9]', $Pattern);
		
		// Support for POSIX syntax
		$Pattern = str_replace('[:digit:]', '0-9', $Pattern);
		$Pattern = str_replace('[:alnum:]', 'A-Za-z0-9', $Pattern);
		$Pattern = str_replace('[:alpha:]', 'A-Za-z', $Pattern);
		$Pattern = str_replace('[:upper:]', 'A-Z', $Pattern);
		$Pattern = str_replace('[:lower:]', 'a-z', $Pattern);
		
		// unprotect escaped back-slashes
		$Pattern = str_replace('{\\\\}', '\\\\', $Pattern);		
	
		return $Pattern;
	}
	
	public function GenerateData()
	{
		// Generate data and substitution bags
		$data_state = $this->_Generate($this->_Prepare($this->_pattern));
		
		// Perform subpattern substitutions
		if ($count = count($data_state->subpattern_products))
		{
			$data_state->subpattern_products = array_merge(array(' '), $data_state->subpattern_products);

			++$count;
			for ($i=$count-1; $i > 0; --$i) // last references processed first
			{
				$data_state->product = str_replace('${'.$i.'}', $data_state->subpattern_products[$i], $data_state->product);
			}
		}
		
		$data_state->product = str_replace('${0}', str_replace('${0}', '', $data_state->product), $data_state->product);
		
		return $data_state->product;
	}
	
	public function GenerateDataFrom($Pattern)
	{
		$this->SetPattern($Pattern);
		return $this->GenerateData();
	}
	
	public function Validate($Data)
	{
		return preg_match('/'.str_replace('/', '\/', $this->_pattern).'/', $Data) > 0;
	}
	
	public function ValidateAgainst($Data, $Pattern)
	{
		$this->SetPattern($Pattern);
		return $this->Validate($Data);
	}
	
	protected function _Generate($pattern)
	{
		$tokens = preg_split(self::$_deliminatorPattern, $pattern, -1, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY);
		
		$state = new RegExpPatternDataGeneratorExpressionState();
		
		$count = count($tokens);
		for ($i = 0; $i < $count; ++$i)
		{
			$state->token = $tokens[$i];
			$state->prev_token = null;
			$state->next_token = null;
			
			if ($i < $count - 1)
			{
				$state->next_token = $tokens[$i + 1];
			}
			
			if ($i)
			{
				$state->prev_token = $tokens[$i - 1];
			}
			
			if (!$state->in_set_mode)
			{
				switch ($state->token)
				{				
					case '.':
						if ($state->next_token != null && in_array($state->next_token{0}, array('?', '+', '*', '{')))
						{
							$state->token = "(?:[{$this->whole_set}]{$state->next_token})";
							++$i;
						}
						else
						{
							$state->token = "(?:[{$this->whole_set}])";
						}
						break;
					case '?':
						$state->token = '{0,1}';
						break;
					case '+':
						$state->token = '{1,}';
						break;
					case '*':
						$state->token = '{0,}';
						break;
				}				
			}
			
			if (!$state->in_set_mode && $state->token == '|')
			{
				if ($state->set_just_closed)
				{
					$this->_ProcessLatestSet($state);
				}
				
				$state->set_just_closed = false;
				$state->inverse_set = false;
				$state->set_members = array();
				
				$state->product_alternatives[] = $state->product.$state->last_generated_data;
				$state->product = $state->last_generated_data = '';
			}
			else if ($state->token{0} == '(')
			{
				if ($state->set_just_closed)
				{
					$this->_ProcessLatestSet($state);
				}
				
				$state->product .= $state->last_generated_data;
				$state->set_just_closed = false;
				$state->inverse_set = false;
				$state->last_generated_data = '';
				$state->set_members = array();
				
				$sub_state = $this->_Generate(substr($state->token, 1, strlen($state->token)-2));
				$state->last_generated_data = $sub_state->product;				
				
				if ($sub_state->subpattern_products_captured)
				{
					$state->subpattern_products[] = $state->last_generated_data;
				}

				$subpattern_count = count($sub_state->subpattern_products);
				if ($subpattern_count > 1 || ($subpattern_count == 1 && !empty($sub_state->subpattern_products[0])))
				{
					$state->subpattern_products = array_merge($state->subpattern_products, $sub_state->subpattern_products);
				}

				if ($i == $count - 1)
				{
					$state->product .= $state->last_generated_data;
				}
			}
			else if ($state->token{0} == '{' && strlen($state->token) > 2)
			{
				$state->expression_repeat_count = substr($state->token, 1, strlen($state->token)-2);
				
				if ($state->expression_repeat_count{strlen($state->expression_repeat_count)-1} == ',')
				{
					$state->expression_repeat_count = mt_rand(intval($state->expression_repeat_count), $this->maxRepetationCount);
				}
				else if (strpos($state->expression_repeat_count, ',') !== false)
				{				
					list($min, $max) = explode(',', $state->expression_repeat_count);
					$state->expression_repeat_count = mt_rand($min,$max);
				}
				else
				{
					$state->expression_repeat_count = intval($state->expression_repeat_count);
				}
				
				if ($state->set_just_closed)
				{					
					$set_count = count($state->set_members) - 1;
					
					if ($state->inverse_set)
					{					
						$current_set = $this->whole_set;
						for ($set_index = 0; $set_index <= $set_count; ++$set_index)
						{							
							for ($k = $state->set_members[$set_index][0]; $k <= $state->set_members[$set_index][1]; ++$k)
							{							
								$current_set = str_replace(chr($k), '', $current_set);
							}
						}						
					}
					
					for ($j = 0; $j < $state->expression_repeat_count; ++$j)
					{
						if ($state->inverse_set)
						{
							$set_index = mt_rand(0, strlen($current_set)-1);
							$char = $current_set{$set_index};
						}
						else
						{
							if ($set_count)
							{
								$set_index = mt_rand(0, $set_count);
							}
							else
							{
								$set_index = 0;
							}
							$char = chr(mt_rand($state->set_members[$set_index][0], $state->set_members[$set_index][1]));
						}							
						$state->product .= $char;
					}
				}
				else
				{
					if ($state->expression_repeat_count)
					{
						$state->product .= str_repeat($state->last_generated_data, $state->expression_repeat_count);
					}
					else if ($state->prev_token{0} == '(' && count($state->subpattern_products))
					{
						$index = count($state->subpattern_products) - 1;
						
						if ($state->subpattern_products[$index] == $state->last_generated_data)
						{						
							unset($state->subpattern_products[$index]);
						}
					}
				}
				$state->last_generated_data = '';
				$state->set_just_closed = false;
				$state->inverse_set = false;
				$state->set_members = array();
			}
			else if ($state->token == '[')
			{
				if ($state->in_set_mode)
				{
					++$state->dummy_set_opener_count;
				}
				else
				{
					if ($state->set_just_closed)
					{
						$this->_ProcessLatestSet($state);
					}
					else
					{
						$state->product .= $state->last_generated_data;
					}
					
					$state->last_generated_data = '';
					$state->set_just_closed = false;
					$state->inverse_set = false;
					$state->set_members = array();					
					$state->in_set_mode = true;
				}
			}
			else if ($state->token == ']')
			{
				if ($state->dummy_set_opener_count)
				{
					--$state->dummy_set_opener_count;
				}
				else
				{
					$state->set_just_closed = true;
					$state->in_set_mode = false;
					
					if ($i == $count - 1)
					{
						$this->_ProcessLatestSet($state);
					}
				}
			}
			else if ($state->in_set_mode && preg_match('/^[\w]\-[\w]$/', $state->token))
			{
				list($min, $max) = split('-', $state->token);
				$state->set_members[] = array(ord($min), ord($max));			
			}			
			else
			{
				if ($state->token{0} == '\\' && $state->token{1} == 'c')
				{
					$state->token = '\x'.dechex(ord($state->token{2}) - ord('A') + 1); // \cX pattern --> \xHH pattern
				}
				
				if ($state->token{0} == '\\' && $state->token{1} == 'Q')
				{
					$state->token = substr($state->token, 2); // \Q...$ pattern
					
					if (substr($state->token, -2) == '\E') // \Q...\E pattern
					{
						$state->token = substr($state->token, 0, -2);
					}
				}
				else if ($state->token{0} == '\\' && strlen($state->token) > 1 && strlen($state->token) < 5)
				{
					if (strlen($state->token) == 2)
					{
						if (is_numeric($state->token{1}))
						{
							if ($state->in_set_mode)
							{
								$state->token = chr(octdec($state->token{1})); // \n pattern -- octal character code
							}
							else
							{							
								$state->token = '${'.$state->token{1}.'}'; // \n pattern -- back-reference
							}
						}
						else if ($state->token{1} == 'n') // \n character
						{
							$state->token = "\n";
						}
						else if ($state->token{1} == 'r') // \r character
						{
							$state->token = "\r";
						}
						else if ($state->token{1} == 't') // \t character
						{
							$state->token = "\t";
						}
						else
						{
							$state->token = $state->token{1};
						}
					}
					else if (strlen($state->token) == 3)
					{
						if ($state->token{1} == 'x') // \xH pattern
						{
							$state->token = chr(hexdec($state->token{2}));
						}
						else if (!$state->in_set_mode) // \nn pattern -- back-reference
						{
							$state->token = '${'.$state->token{1}.$state->token{2}.'}';
						}
						else if ($state->in_set_mode) // \nn pattern -- octal character code
						{
							$state->token = chr(octdec($state->token{1}.$state->token{2}));						
						}
					}
					else if (strlen($state->token) == 4) // \xHH pattern
					{
						$state->token = chr(hexdec($state->token{2}.$state->token{3}));
					}
				}
				else if (!$state->in_set_mode && $state->token{0} == '$' && strlen($state->token) > 1 && strlen($state->token) < 6)
				{
					if ($state->token{1} != '{')
					{
						if (strlen($state->token) == 2) // $n pattern
						{
							$state->token = '${'.$state->token{1}.'}';							
						}					
						else if (strlen($state->token) == 3) // $nn pattern
						{
							$state->token = '${'.$state->token{1}.$state->token{2}.'}';							
						}
					}
				}
				
				if ($state->in_set_mode)
				{
					if ($state->token{0} == '^')
					{
						$state->inverse_set = true;
					}
					else
					{					
						$set_count = strlen($state->token);
						for ($j=0; $j < $set_count; ++$j)
						{
							$state->set_members[] = array(ord($state->token{$j}), ord($state->token{$j}));
						}
					}
				}
				else
				{
					if ($state->set_just_closed)
					{
						$this->_ProcessLatestSet($state);
						
						$state->inverse_set = false;
						$state->set_just_closed = false;
					}
					
					$state->product .= $state->last_generated_data;
					if ($i == $count - 1 && $state->token != '?:')
					{
						$state->product .= $state->token;
					}
					
					if ($state->token != '?:')
					{
						$state->last_generated_data = $state->token;
					}					
				}
			}
		}
		
		if (count($state->product_alternatives))
		{
			$state->product_alternatives[] = $state->product;
			
			$state->product = $state->product_alternatives[mt_rand(0, count($state->product_alternatives)-1)];
		}
		
		$state->subpattern_products_captured = $tokens[0] != '?:';
		
		return $state;
	}
	
	protected function _ProcessLatestSet(RegExpPatternDataGeneratorExpressionState &$state)
	{
		$set_count = count($state->set_members) - 1;
		
		if ($state->inverse_set)
		{								
			$current_set = $this->whole_set;
			for ($set_index = 0; $set_index <= $set_count; ++$set_index)
			{
				for ($i = $state->set_members[$set_index][0]; $i <= $state->set_members[$set_index][1]; ++$i)
				{
					$current_set = str_replace(chr($i), '', $current_set);
				}
			}
		
			$set_index = mt_rand(0, strlen($current_set)-1);
			$char = $current_set{$set_index};
		}
		else
		{
			if ($set_count)
			{
				$set_index = mt_rand(0, $set_count);
			}
			else
			{
				$set_index = 0;
			}
			
			$char = chr(mt_rand($state->set_members[$set_index][0], $state->set_members[$set_index][1]));
		}
		
		$state->product .= $char;
	}
}

class RegExpPatternDataGeneratorExpressionState
{
	public $token;
	public $next_token;
	public $prev_token;
	
	public $product = '';
	public $product_alternatives = array();
	
	public $subpattern_products = array();
	public $subpattern_products_captured = true;
		
	public $last_generated_data = '';
	public $expression_repeat_count = 1;
		
	public $dummy_set_opener_count = 0;
	public $in_set_mode = false;
	public $inverse_set = false;
	public $set_just_closed = false;
	public $set_members = array();		
}