<?php

class RegExpPatternDataGenerator implements IPatternDataGenerator
{
	protected $_pattern;
	
	// what will be the max length of string generated by repetation (+, *, {n,n}) operators?
	public $maxRepetationCount = 16; 
	
	// meaning of the "." character
	public $whole_set;
		
	protected static $_deliminatorPattern = '';
	
	public function __construct()
	{
		$this->_pattern = '';
		$this->whole_set = join('', array_merge(range('a','z'), range('A','Z'), range('0','9')))." \t!\"#\$%&'()*+,-./:;<=>?@\[\]\\^_`{|}~";
		
		if (empty(self::$_deliminatorPattern))
		{
			// Build tokenizer rules
			$deliminators = array();		
			$deliminators[] = '\\\\x[0-9a-fA-F]{1,2}';	// support the \xHH syntax
			$deliminators[] = '\\\\c[A-Z]';	// support the \cX syntax
			$deliminators[] = '\\\\[0-9]{1,2}'; // support back-references (\nn syntax)
			$deliminators[] = '\\\\Q.*?\\\\E|\\\\Q.*?$'; // support escaping as literals (\Q...\E syntax)
			$deliminators[] = '\\\\.'; // support escaping special characters
			$deliminators[] = '\$\{[0-9]{1,2}\}'; // support back-references (${nn} syntax)
			$deliminators[] = '\$[0-9]{1,2}'; // support back-references ($nn syntax)
			$deliminators[] = '\?:'; // support non-capturing subpatterns
			$deliminators[] = '\(((?>[^()]*)|(?R))*\)'; // support subpatterns
			$deliminators[] = '[\w]\-[\w]'; // support alpha-numeric intervals
			$deliminators[] = '\{\d+,?\}|\{\d+,\d+\}'; // support the repetation operators ({n}, {n,}, {n,n})			
			$deliminators[] = '.'; // pass-thru everything else to the phase 2
			
			self::$_deliminatorPattern = '/'.join('|', array_map(create_function('$deliminator', 'return "($deliminator)";'), $deliminators)).'/sD';
		}
	}
	
	public function SetPattern($Pattern)
	{
		$this->_pattern = $Pattern;
	}
	
	public function GetPattern()
	{
		return $this->_pattern;
	}	
	
	protected function _Prepare($Pattern)
	{
		// protect escaped back-slashes
		$Pattern = str_replace('\\\\', '{\\\\}', $Pattern);
		
		// ignore the beginning/ending of line/data rules
		$Pattern = preg_replace('/^[\^]/'		, ''	, $Pattern);
		$Pattern = preg_replace('/([^\\\])\$$/'	, '$1'	, $Pattern);
		$Pattern = preg_replace('/^\\\A/'		, ''	, $Pattern);
		$Pattern = preg_replace('/\\\Z$/'		, ''	, $Pattern);
		
		// Unicode support is not fully implemented yet
		// $Pattern = preg_replace('/(\\\P(\^Ll|\{?\^Ll\}?))|(\\\P(Ll|\{?Ll\}?))/'							, 	'[A-Z0-9]'	, $Pattern);
		// $Pattern = preg_replace('/(\\\p(\^Lu|\{?\^Lu\}?))|(\\\P(Lu|\{?Lu\}?))/'							, 	'[a-z0-9]'	, $Pattern);
		// $Pattern = preg_replace('/\\\p(Lu|\{?Lu\}?)/'													, 	'[A-Z]'		, $Pattern);
		// $Pattern = preg_replace('/\\\p(Ll|\{?Ll\}?)/'													, 	'[a-z]'		, $Pattern);
		// $Pattern = preg_replace('/(\\\p(Nd?|\{?Nd?\}?))|(\\\P(L|\{?L\}?))|(\\\p(\^L|\{?\^L\}?))/'		,	'[0-9]'		, $Pattern);
		// $Pattern = preg_replace('/(\\\p(L|\{?L\}?))|(\\\P(Nd?|\{?Nd?\}?))|(\\\p(\^Nd?|\{?\^Nd?\}?))/'	, 	'[A-Za-z]'	, $Pattern);
		
		// Support for PCRE character properties
		$Pattern = str_replace('\S', '[^\s]'		, $Pattern);
		$Pattern = str_replace('\s', "[ \t\n\r]"	, $Pattern);
		$Pattern = str_replace('\B', '\w'			, $Pattern);
		$Pattern = str_replace('\b', '\W'			, $Pattern);
		$Pattern = str_replace('\W', '[^\w]'		, $Pattern);
		$Pattern = str_replace('\w', '[a-zA-Z\d_]'	, $Pattern);
		$Pattern = str_replace('\D', '[^\d]'		, $Pattern);
		$Pattern = str_replace('\d', '[0-9]'		, $Pattern);
		
		// Support for POSIX syntax
		$Pattern = str_replace('[:digit:]', '0-9'		, $Pattern);
		$Pattern = str_replace('[:alnum:]', 'A-Za-z0-9'	, $Pattern);
		$Pattern = str_replace('[:alpha:]', 'A-Za-z'	, $Pattern);
		$Pattern = str_replace('[:upper:]', 'A-Z'		, $Pattern);
		$Pattern = str_replace('[:lower:]', 'a-z'		, $Pattern);
		
		// unprotect escaped back-slashes
		$Pattern = str_replace('{\\\\}', '\\\\', $Pattern);		
	
		return $Pattern;
	}
	
	public function GenerateData()
	{
		// Generate data and substitution bags
		list($result, $inner_substring) = $this->_Generate($this->_Prepare($this->_pattern));
		
		// Perform subpattern substitutions
		if ($count = count($inner_substring))
		{
			$substring = array_merge(array(' '), $inner_substring);

			++$count;
			for ($i=$count-1; $i > 0; --$i) // last references processed first
			{
				$result = str_replace('${'.$i.'}', $substring[$i], $result);
			}
		}
		
		$result = str_replace('${0}', str_replace('${0}', '', $result), $result);
		
		return $result;
	}
	
	public function GenerateDataFrom($Pattern)
	{
		$this->SetPattern($Pattern);
		return $this->GenerateData();
	}
	
	public function Validate($Data)
	{
		return preg_match('/'.str_replace('/', '\/', $this->_pattern).'/', $Data) > 0;
	}
	
	public function ValidateAgainst($Data, $Pattern)
	{
		$this->SetPattern($Pattern);
		return $this->Validate($Data);
	}
	
	protected function _Generate($pattern)
	{
		$tokens = preg_split(self::$_deliminatorPattern, $pattern, -1, PREG_SPLIT_DELIM_CAPTURE|PREG_SPLIT_NO_EMPTY);
		
		$result = '';
		
		$repeat_count = 1;
		$set_ignore_limit = 0;
		
		$last_string = '';
		
		$in_set_mode = false;
		$inverse_set = false;
		$set_just_closed = false;
		$set_interval = array();
		
		$substring = array();
		
		$result_set = array();
		
		$count = count($tokens);
		for ($i = 0; $i < $count; ++$i)
		{
			$next_token = null;
			$token = $tokens[$i];
			
			if ($i < $count - 1)
			{
				$next_token = $tokens[$i + 1];
			}
			
			if (!$in_set_mode)
			{
				switch ($token)
				{				
					case '.':
						if ($next_token != null && (in_array($next_token, array('?', '+', '*')) || $next_token{0} == '{' && strlen($next_token) > 2))
						{
							$token = "(?:[{$this->whole_set}]$next_token)";
							++$i;
						}
						else
						{
							$token = "(?:[{$this->whole_set}])";
						}
						break;
					case '?':
						$token = '{0,1}';
						break;
					case '+':
						$token = '{1,}';
						break;
					case '*':
						$token = '{0,}';
						break;
				}				
			}
			
			if (!$in_set_mode && $token == '|')
			{
				if ($set_just_closed)
				{
					$set_count = count($set_interval) - 1;
					if ($inverse_set)
					{								
						$current_set = $this->whole_set;
						for ($set_index = 0; $set_index <= $set_count; ++$set_index)
						{
							for ($k = $set_interval[$set_index][0]; $k <= $set_interval[$set_index][1]; ++$k)
							{
								$current_set = str_replace(chr($k), '', $current_set);
							}
						}
					
						$set_index = mt_rand(0, strlen($current_set)-1);
						$char = $current_set{$set_index};
					}
					else
					{
						if ($set_count)
						{
							$set_index = mt_rand(0, $set_count);
						}
						else
						{
							$set_index = 0;
						}
						$char = chr(mt_rand($set_interval[$set_index][0], $set_interval[$set_index][1]));
					}							
					$result .= $char;				
				}
				
				$set_just_closed = false;
				$inverse_set = false;
				$set_interval = array();
				
				$result_set[] = $result.$last_string;
				$result = $last_string = '';
			}
			else if ($token{0} == '(')
			{
				if ($set_just_closed)
				{
					$set_count = count($set_interval) - 1;
					if ($inverse_set)
					{								
						$current_set = $this->whole_set;
						for ($set_index = 0; $set_index <= $set_count; ++$set_index)
						{
							for ($k = $set_interval[$set_index][0]; $k <= $set_interval[$set_index][1]; ++$k)
							{
								$current_set = str_replace(chr($k), '', $current_set);
							}
						}
					
						$set_index = mt_rand(0, strlen($current_set)-1);
						$char = $current_set{$set_index};
					}
					else
					{
						if ($set_count)
						{
							$set_index = mt_rand(0, $set_count);
						}
						else
						{
							$set_index = 0;
						}
						$char = chr(mt_rand($set_interval[$set_index][0], $set_interval[$set_index][1]));
					}							
					$result .= $char;				
				}
				
				$result .= $last_string;
				$set_just_closed = false;
				$inverse_set = false;
				$last_string = '';
				$set_interval = array();
				
				list($inner_result, $inner_substring, $inner_include_me) = $this->_Generate(substr($token, 1, strlen($token)-2));
				$last_string = $inner_result;				
				
				if ($inner_include_me)
				{
					$substring[] = $last_string;
				}

				if (count($inner_substring) > 1 || (count($inner_substring) == 1 && !empty($inner_substring[0])))
				{
					$substring = array_merge($substring, $inner_substring);
				}

				if ($i == $count - 1)
				{
					$result .= $last_string;
				}
			}
			else if ($token{0} == '{' && strlen($token) > 2)
			{
				$repeat_count = substr($token, 1, strlen($token)-2);
				
				if ($repeat_count{strlen($repeat_count)-1} == ',')
				{
					$repeat_count = mt_rand(intval($repeat_count), $this->maxRepetationCount);
				}
				else if (strpos($repeat_count, ',') !== false)
				{				
					list($min,$max) = explode(',', $repeat_count);
					$repeat_count = mt_rand($min,$max);
				}
				else
				{
					$repeat_count = intval($repeat_count);
				}
				
				if ($set_just_closed)
				{					
					$set_count = count($set_interval) - 1;
					if ($inverse_set)
					{					
						$current_set = $this->whole_set;
						for ($set_index = 0; $set_index <= $set_count; ++$set_index)
						{							
							for ($k = $set_interval[$set_index][0]; $k <= $set_interval[$set_index][1]; ++$k)
							{							
								$current_set = str_replace(chr($k), '', $current_set);
							}
						}						
					}
					
					for ($j = 0; $j < $repeat_count; ++$j)
					{
						if ($inverse_set)
						{
							$set_index = mt_rand(0, strlen($current_set)-1);
							$char = $current_set{$set_index};
						}
						else
						{
							if ($set_count)
							{
								$set_index = mt_rand(0, $set_count);
							}
							else
							{
								$set_index = 0;
							}
							$char = chr(mt_rand($set_interval[$set_index][0], $set_interval[$set_index][1]));
						}							
						$result .= $char;
					}
				}
				else
				{
					$result .= str_repeat($last_string, $repeat_count);
					
					if (!$repeat_count && $tokens[$i-1]{0} == '(' && count($substring) && $substring[count($substring)-1] == $last_string)
					{
						unset($substring[count($substring)-1]);
					}
				}
				$set_just_closed = false;
				$inverse_set = false;
				$last_string = '';
				$set_interval = array();
			}
			else if ($token == '[')
			{
				if ($in_set_mode)
				{
					++$set_ignore_limit;
				}
				else
				{
					if ($set_just_closed)
					{
						$set_count = count($set_interval) - 1;
						if ($inverse_set)
						{
							$current_set = $this->whole_set;
							for ($set_index = 0; $set_index <= $set_count; ++$set_index)
							{
								for ($k = $set_interval[$set_index][0]; $k <= $set_interval[$set_index][1]; ++$k)
								{
									$current_set = str_replace(chr($k), '', $current_set);
								}
							}
						
							$set_index = mt_rand(0, strlen($current_set)-1);
							$char = $current_set{$set_index};
						}
						else
						{
							if ($set_count)
							{
								$set_index = mt_rand(0, $set_count);
							}
							else
							{
								$set_index = 0;
							}
							$char = chr(mt_rand($set_interval[$set_index][0], $set_interval[$set_index][1]));
						}							
						$result .= $char;
					}
					else
					{
						$result .= $last_string;
					}
					
					$set_just_closed = false;
					$inverse_set = false;
					$last_string = '';
					$set_interval = array();
					
					$in_set_mode = true;
				}
			}
			else if ($token == ']')
			{
				if ($set_ignore_limit)
				{
					--$set_ignore_limit;
				}
				else
				{
					$set_just_closed = true;
					$in_set_mode = false;
					if ($i == $count - 1)
					{
						$set_count = count($set_interval) - 1;
						if ($inverse_set)
						{								
							$current_set = $this->whole_set;
							for ($set_index = 0; $set_index <= $set_count; ++$set_index)
							{
								for ($k = $set_interval[$set_index][0]; $k <= $set_interval[$set_index][1]; ++$k)
								{
									$current_set = str_replace(chr($k), '', $current_set);
								}
							}
						
							$set_index = mt_rand(0, strlen($current_set)-1);
							$char = $current_set{$set_index};
						}
						else
						{
							if ($set_count)
							{
								$set_index = mt_rand(0, $set_count);
							}
							else
							{
								$set_index = 0;
							}
							$char = chr(mt_rand($set_interval[$set_index][0], $set_interval[$set_index][1]));
						}							
						$result .= $char;
					}
				}
			}
			else if ($in_set_mode && preg_match('/^[\w]\-[\w]$/', $token))
			{
				list($min, $max) = split('-', $token);
				$set_interval[] = array(ord($min), ord($max));			
			}			
			else
			{
				if ($token{0} == '\\' && $token{1} == 'c')
				{
					$token = '\x'.dechex(ord($token{2}) - ord('A') + 1);					
				}
				
				if ($token{0} == '\\' && $token{1} == 'Q')
				{
					$token = substr($token, 2);
					
					if (substr($token, -2) == '\E')
					{
						$token = substr($token, 0, -2);
					}
				}
				else if ($token{0} == '\\' && strlen($token) > 1 && strlen($token) < 5)
				{
					if (strlen($token) == 2)
					{
						if (is_numeric($token{1}))
						{
							$token = '${'.$token{1}.'}';
						}
						else if ($token{1} == 'n')
						{
							$token = "\n";
						}
						else if ($token{1} == 'r')
						{
							$token = "\r";
						}
						else if ($token{1} == 't')
						{
							$token = "\t";
						}
						else
						{
							$token = $token{1};
						}
					}
					else if (strlen($token) == 3)
					{
						if ($token{1} == 'x')
						{
							$token = chr(hexdec($token{2}));
						}
						else
						{
							$token = '${'.$token{1}.$token{2}.'}';
						}
					}
					else if (strlen($token) == 4)
					{
						$token = chr(hexdec($token{2}.$token{3}));
					}
				}
				else if ($token{0} == '$' && strlen($token) > 1 && strlen($token) < 6)
				{
					if ($token{1} != '{')
					{
						if (strlen($token) == 2)
						{
							$token = '${'.$token{1}.'}';							
						}					
						else if (strlen($token) == 3)
						{
							$token = '${'.$token{1}.$token{2}.'}';							
						}
					}
				}
				
				if ($in_set_mode)
				{
					if ($token{0} == '^')
					{
						$inverse_set = true;
					}
					else
					{					
						$set_count = strlen($token);
						for ($j=0; $j < $set_count; ++$j)
						{
							$set_interval[] = array(ord($token{$j}), ord($token{$j}));
						}
					}
				}
				else
				{
					if ($set_just_closed)
					{
						$set_count = count($set_interval) - 1;
						if ($inverse_set)
						{								
							$current_set = $this->whole_set;
							for ($set_index = 0; $set_index <= $set_count; ++$set_index)
							{
								for ($k = $set_interval[$set_index][0]; $k <= $set_interval[$set_index][1]; ++$k)
								{
									$current_set = str_replace(chr($k), '', $current_set);
								}
							}
					
							$set_index = mt_rand(0, strlen($current_set)-1);
							$char = $current_set{$set_index};
						}
						else
						{
							if ($set_count)
							{
								$set_index = mt_rand(0, $set_count);
							}
							else
							{
								$set_index = 0;
							}
							$char = chr(mt_rand($set_interval[$set_index][0], $set_interval[$set_index][1]));
						}							
						$result .= $char;
						$inverse_set = false;
						$set_just_closed = false;
					}
					
					$result .= $last_string;
					if ($i == $count - 1 && $token != '?:')
					{
						$result .= $token;
					}
					
					if ($token != '?:')
					{
						$last_string = $token;
					}					
				}
			}
		}
		
		if (count($result_set))
		{
			$result_set[] = $result;
			
			$result = $result_set[mt_rand(0, count($result_set)-1)];
		}
		
		return array($result, $substring, $tokens[0] != '?:');
	}
}

